# 문자열 검색

---

N: 텍스트의 길이
M: 패턴의 길이

## 단순한 문자열 검색

![img.png](img/BF_string_search.png)

- O(N * M)

## KMP 알고리즘

---

- 다음 문자부터 탐색하는 것이 아닌, 앞서 탐색했던 정보를 이용하여 몇 칸 더 건너띄는게 가능한가? 
  - 건너 띈 후의 부분이 동일하면 가능하다.
  - 그래야 그 이후로 탐색하는게 의미가 있기 때문


### 접두사와 접미사

ex. banana

**접두사 (prefix)**
```
b
ba
ban
bana
banan
banana
```

**접미사 (prefix)**
```
a
na
ana
nana
anana
banana
```

KMP 알고리즘에서 정의하는 접두사, 접미사?
- 문자열 맨 앞과 맨 뒤에서 같은 문자열이 나오는 경우


### pi 배열
- pi[i]: 주어진 문자열의 0 ~ i 까지의 부분 문자열 중, prefix == suffix 가 될 수 있는 부분 문자열 중에서 가장 긴 것의 길이'
- ex. 주어진 문자열: ABAABAB

| i | 부분 문자열  | pi[i] |
|---|---------|-------|
| 0 | A       | 0     |
| 1 | AB      | 0     |
| 2 | ABA     | 1     |
| 3 | ABAA    | 1     |
| 4 | ABAAB   | 2     |
| 5 | ABAABA  | 3     |
| 6 | ABAABAB | 2     |

### 구현

1. pi 배열을 구한다.
2. text <> pattern 의 각 문자를 검사하면서 일치하는지 확인한다.
   1. 일치하면 다음인덱스를 이어서 확인하고
   2. 불일치시 바로 전까지의 인덱스를 통해 pi 배열의 값을 얻어온다. 해당 pi 배열의 값을 인덱스로 하는 pattern 문자 위치를 방금 불일치한 문자 위치로 변경한 후 둘을 비교한다.
   3. 여기서 일치하면 1번 과정으로 돌아가고,
   4. 여기서 불일치하면 전체 한 칸 앞으로 이동 후 1번부터 다시 시작한다.


## AC (Aho-Corasick)

---

- 패턴 하나를 탐색하는 매칭 알고리즘은 KMP를 통해 선형시간에 해결가능
- 다만, 패턴 개수가 많아지면 그 개수에 비례해서 속도가 느려진다.
  - m = 모든 패턴들의 길이의 합
  - p = 패턴 수
  - n = text 의 크기
  - O(m + p * n)
- 아호 코라식 알고리즘을 이용하면 O(m + p + n)의 시간복잡도로 다양한 패턴집합에 대한 탐색도 선형시간에 해결이 가능하다. 이때, trie를 활용한다.
  - 패턴 문자열의 개수와 상관없이 원본 문자열을 한 번만 훑어서 매칭된 문자열을 찾아낸다.

### 실패함수
다음 글자가 대응하는데 실패했을 때 다음으로 가서 시도해야 할 노드의 포인터 할당

1. Trie 루트로부터 BFS 를 수행하면서 Failure Link 만들기
2. 현재 위치(p)와 가리키는 노드(q)에 대해서
   1. p == root, failure(q) = root
   2. p != root, p의 실패링크에서 q와 같은 문자로 이어지는 노드(r)가 있는지 확인한다.
      1. 있다면 f(q) = r
      2. 없다면 p 에 f(p)를 대입한 뒤 i 부터 과정을 반복한다.

### 출력 문자열 목록
- 각 노드에 도달했을 때 어떤 pattern들을 발견하게 되는가?
- 한 pattern이 다른 pattern의 부분집합인 경우, 해당 pattern이 종료되는 노드 외의 장소에서도 문자열을 발견할 수 있으므로 별도의 목록이 필요하다.
    - ex. patterns = [ABC, B, BC] 이면 AB에 도달했을 때 B를, ABC에 도달했을 때 BC를 발견하는 등 ...

## References
### KMP Algorithm
- https://bowbowbow.tistory.com/6

### Aho-Corasick Algorithm
- https://www.slideshare.net/slideshow/ahocorasick-algorithm/53152784